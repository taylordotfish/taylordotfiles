#!/bin/sh
# Copyright (C) 2023-2024 taylor.fish <contact@taylor.fish>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

set -euf

USAGE="\
Usage: $(basename "$0") <command>

Operates on every Git repository in the current directory, where <command> is:

  unpushed   Find local changes not present in remotes.
  unpulled   Find remotes with changes not merged locally.
  fetch      Fetch all remotes.
  ff         Try to fast-forward to the remote tracking branch.
  submodule  Initialize and update submodules.
  sync       Sync submodule URLs.
"

unpushed() {
    if ! git -C "$1" branch | grep . > /dev/null; then
        printf '%s\n' "$1"
        return 0
    fi
    if ! git -C "$1" diff --name-only --exit-code > /dev/null; then
        local uncommitted=1
    fi
    local branch=$(git -C "$1" rev-parse --abbrev-ref HEAD)
    local pushed=
    local unpushed=
    local remote
    for remote in $(git -C "$1" remote); do
        if [ -n "${uncommitted-}" ] ||
            ! git -C "$1" rev-parse --abbrev-ref "$remote/$branch" \
                > /dev/null 2>&1 ||
            ! git -C "$1" diff "$remote/$branch..." --name-only --exit-code \
                > /dev/null
        then
            unpushed="${unpushed:+$unpushed,}$remote"
        else
            pushed="${pushed:+$pushed,}$remote"
        fi
    done
    if [ -n "$unpushed" ]; then
        printf '%s: %s%s\n' "$1" "$unpushed" "${pushed:+ (-$pushed)}"
    fi
}

unpulled() {
    if ! git -C "$1" branch | grep . > /dev/null; then
        return 0
    fi
    local branch=$(git -C "$1" rev-parse --abbrev-ref HEAD)
    local remotes=
    local remote
    for remote in $(git -C "$1" remote); do
        if ! git -C "$1" rev-parse --abbrev-ref "$remote/$branch" \
            > /dev/null 2>&1
        then
            continue
        fi
        if git -C "$1" log "..$remote/$branch" --format=oneline |
            grep . > /dev/null
        then
            remotes="${remotes:+$remotes,}$remote"
        fi
    done
    if [ -n "$remotes" ]; then
        printf '%s: %s\n' "$1" "$remotes"
    fi
}

fetch() {
    printf '[%s]\n' "$1"
    git -C "$1" fetch --all || true
}

ff() {
    printf '[%s]\n' "$1"
    git -C "$1" merge --ff-only || true
}

submodule() {
    printf '[%s]\n' "$1"
    git -C "$1" submodule update --init --recursive
}

sync() {
    printf '[%s]\n' "$1"
    git -C "$1" submodule sync --recursive
}

if [ "$#" -ne 1 ]; then
    printf >&2 '%s' "$USAGE"
    exit 1
fi

case "$1" in
    unpushed|unpulled|fetch|ff|submodule|sync)
        set +f
        for d in *; do
            set -f
            [ -d "$d/.git" ] && "$1" "$d"
        done
        ;;
    -h|--help)
        printf '%s' "$USAGE"
        ;;
    *)
        printf >&2 '%s' "$USAGE"
        exit 1
        ;;
esac
