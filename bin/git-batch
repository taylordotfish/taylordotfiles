#!/bin/sh
# Copyright (C) 2023-2024 taylor.fish <contact@taylor.fish>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

set -euf

usage() {
    cat << EOF
Usage: $(basename "$0") <command>

Operates on every Git repository in the current directory, where <command> is:

  unpushed   Find local changes not present in remotes.
  unpulled   Find remotes with changes not merged locally.
  fetch      Fetch all remotes.
  ff         Try to fast-forward to the remote tracking branch.
  submodule  Initialize and update submodules.
  sync       Sync submodule URLs.
  branch     Show the current branch.
EOF
}

alias get_subdir_repos='
    set +f; set -f -- *
    local d 2> /dev/null || true
    for d do
        shift
        if [ -d "$d/.git" ]; then
            set -- "$@" "$d"
        fi
    done
'

alias get_repos='
    if [ -d .git ]; then
        set -- .
    else
        get_subdir_repos
    fi
'

unpushed() {
    if ! git -C "$1" branch | grep -q .; then
        printf '%s\n' "$1"
        return 0
    fi
    if ! git -C "$1" diff --name-only --exit-code > /dev/null; then
        local uncommitted=1
    fi
    local branch=$(git -C "$1" rev-parse --abbrev-ref HEAD)
    local pushed=
    local unpushed=
    local remote
    for remote in $(git -C "$1" remote); do
        if [ -n "${uncommitted-}" ] ||
            ! git -C "$1" rev-parse --abbrev-ref "$remote/$branch" \
                > /dev/null 2>&1 ||
            ! git -C "$1" diff "$remote/$branch..." --name-only --exit-code \
                > /dev/null
        then
            unpushed="${unpushed:+$unpushed,}$remote"
        else
            pushed="${pushed:+$pushed,}-$remote"
        fi
    done
    if [ -n "$unpushed" ]; then
        printf '%s: %s%s\n' "$1" "$unpushed" "${pushed:+ ($pushed)}"
    fi
}

unpulled() {
    if ! git -C "$1" branch | grep -q .; then
        return 0
    fi
    local branch=$(git -C "$1" rev-parse --abbrev-ref HEAD)
    local remotes=
    local remote
    for remote in $(git -C "$1" remote); do
        if ! git -C "$1" rev-parse --abbrev-ref "$remote/$branch" \
            > /dev/null 2>&1
        then
            continue
        fi
        if git -C "$1" log "..$remote/$branch" --format=oneline | grep -q .
        then
            remotes="${remotes:+$remotes,}$remote"
        fi
    done
    if [ -n "$remotes" ]; then
        printf '%s: %s\n' "$1" "$remotes"
    fi
}

fetch() {
    printf '[%s]\n' "$1"
    git -C "$1" fetch --all || true
}

ff() {
    printf '[%s]\n' "$1"
    git -C "$1" merge --ff-only || true
}

submodule() {
    printf '[%s]\n' "$1"
    git -C "$1" submodule update --init --recursive
}

sync() {
    printf '[%s]\n' "$1"
    git -C "$1" submodule sync --recursive
}

branch() {
    get_repos
    local maxlen=$(printf '%s\n' "$@" | awk '
        length($0) > n { n = length($0) }
        END { print n }
    ')
    for d do
        printf "%${maxlen}s: " "$d"
        git -C "$d" branch --show-current
    done
}

if [ "$#" -ne 1 ]; then
    usage >&2
    exit 1
fi

case "$1" in
    unpushed|unpulled|fetch|ff|submodule|sync)
        get_repos
        for d do
            "$1" "$d"
        done
        ;;
    branch)
        branch
        ;;
    -h|--help)
        usage
        ;;
    *)
        usage >&2
        exit 1
        ;;
esac
